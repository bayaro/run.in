#!/bin/sh

USE_HOSTS_LIST_CACHE=1
RUN_IN_PARALLEL=0
SHOW_SUMMARY=0
SSH=0
while true; do
    case "$1" in
        -y) YES=1
            ;;
        -d) DEBUG=1
            ;;
        -g) PATTERN=$2
            shift
            ;;
        -s) SSH=1
            ;;
        -r) SYNCENV=1
            ;;
        -sr) SSH=1 SYNCENV=1
            ;;
        -sum) SHOW_SUMMARY=1 YES=1
            ;;
        -nocache) USE_HOSTS_LIST_CACHE=0
            ;;
        -par) RUN_IN_PARALLEL=1 YES=1 SHOW_SUMMARY=1
            ;;
        *) break
            ;;
    esac
    shift
done

ME=`basename $0`
HOSTS_LIST_CACHE="/tmp/$ME.cache"
VERBOSE_PREFIX='===>'

verbose() {
    if [ -e "$1" ]; then
        TO="$1"
        shift
    else
        TO=/dev/stderr
    fi
    echo "\033[0;35m$VERBOSE_PREFIX $@\033[0;0m" >> "$TO"
}

if [ $SSH -eq 1 ] && ( [ $RUN_IN_PARALLEL -eq 1 ] || [ $SHOW_SUMMARY -eq 1 ] ); then
    verbose "Could not ssh with RUN_IN_PARALLEL or SHOW_SUMMARY!!!!"
    exit 1
fi

if [ $SSH -eq 1 ]; then
    REMOTE_CMD=ssh
else
    REMOTE_CMD="$@"
    if [ ${#REMOTE_CMD} -eq 0 ]; then USE_HOSTS_LIST_CACHE=0; fi
fi

PROFILE=`echo "$ME" | sed -E 's/run.in.(.*).sh/\1/'`

if [ ! -e "$HOSTS_LIST_CACHE" ] || [ $USE_HOSTS_LIST_CACHE -ne 1 ]; then
    verbose ">>>>>> $REMOTE_CMD"
    HOSTS=`aws --output text --profile $PROFILE --region eu-west-1 ec2 describe-instances \
        --query 'Reservations[*].Instances[*].[PrivateIpAddress,NetworkInterfaces[*].PrivateIpAddresses,Tags,State.Name,Platform,InstanceId]'`
        #--instance-ids i-0f98c3e67f0f50bde \
else
    verbose "CACHED >>>>>> $REMOTE_CMD"
    HOSTS=`cat "$HOSTS_LIST_CACHE"`
fi
if [ $? -ne 0 ]; then
    exit 1
fi
echo "$HOSTS" > "$HOSTS_LIST_CACHE"

HOSTS=`echo "$HOSTS" | grep -E '^(Env|Name|True\s*|10\.10|None)'`
HOSTS=`echo "$HOSTS" | awk '{
        split($0,a," ");
        if ( a[1] == "Name" ) { host[0] = a[2] ? a[2] : "empty" }
        else if ( a[1] == "Environment" ) { host[1] = a[2] ? a[2] : "empty" }
        else if ( a[1] == "True" ) {
            if ( a[3] != host["ip"] ) host[2] = host[2]","a[3]
        }
        else {
            if ( host["ip"] ) {
                printf "%s##%s##%s##%s##%s##%s##%s\n",host[1],host[0],host["ip"],host["state"],host["Platform"],host["aid"],host[2]
                delete host
            }
            host[0] = "?"; host[1] = "?"
            if ( a[5] != "" ) {
                delete a[1]
                n = ""
                for (i in a) {
                    n = n " " a[i]
                }
                split(n,a," ")
            }
            host["ip"] = a[1]
            host["state"] = a[2]
            if ( a[3] == "None" ) a[3] = "-"
            host["Platform"] = a[3]
            host["aid"] = a[4]
        }
    } END {
        printf "%s##%s##%s##%s##%s##%s##%s\n",host[1],host[0],host["ip"],host["state"],host["Platform"],host["aid"],host[2]
    }' | sort -g`
HOSTS=`echo "$HOSTS" | sed 's/##,/##/g'`
#echo "$HOSTS=="
if [ ! -z "$PATTERN" ]; then
    HOSTS=`echo "$HOSTS" | grep -E "$PATTERN"`
    if [ "x$HOSTS" = "x" ]; then
        verbose "There are no hosts that contains '$PATTERN' in its description"
        exit 1
    fi
fi

if [ -z "$2" ] && [ "x$REMOTE_CMD" = "x" ]; then
    echo "$HOSTS" | sed 's/##/ /g' | sort -k 1 | awk -F ' ' '{printf "===> %-14s %20s %s: %s (%s %s) %s\n",$3,$6,$1,$2,$4,$5,$7}' | grep --color=auto -E "$PATTERN"
    exit 0
fi

HOSTS=`echo "$HOSTS" | grep -v '##windows##'`
HOSTTODOCOUNT=`echo "$HOSTS" | wc -l | awk '{print $1}'`
HOSTSEQNUM=0

add_key() {
    cat ~/.ssh/id_rsa.pub | ssh $host 'if [ ! -d .ssh ]; then mkdir .ssh; fi ; cat > ~/.ssh/authorized_keys'
}

process_host() {
    verbose $1 "--------------------------------------------------------------------------------"
    verbose $1 "`echo $h | sed 's/##/ /g' | awk -F ' ' -v HSN=$HOSTSEQNUM -v HTDC=$HOSTTODOCOUNT '{printf "(%02d/%d) %-14s %20s %s: %s (%s %s) %s\n",HSN,HTDC,$3,$6,$1,$2,$4,$5,$7}' | grep --color=always -E "$PATTERN"`"
    local state=`echo $h | awk -F '##' '{print $4}'`
    if [ "$state" != "running" ]; then continue; fi
    local platform=`echo $h | awk -F '##' '{print $5}'`
    if [ "$platform" != "-" ]; then continue; fi

    env=`echo $h | awk -F '##' '{print $1}'`
    name=`echo $h | awk -F '##' '{print $2}'`
    otherip=`echo $h | awk -F '##' '{print $7}'`
    #if [ "x$otherip" != "x" ]; then
    #    ip=$otherip
    #    otherip=`echo $h | awk -F '##' '{print $3}'`
    #fi

    USEPROXY=0
    while [ true ]; do
        if [ $SSH -eq 1 ]; then
            USEPROXY=1 # always use proxy
            if [ ! -z "$SYNCENV" ]; then
                verbose $1 "Synchronizing ..."
                cd ~/bin
                rsync -a -e "ssh -A $PROXY_PREF$PROFILE$PROXY_SUF ssh -o StrictHostKeyChecking=no" .bashrc .bash_profile .bash_completion vim/.vimrc baya@$ip:
                cd - > /dev/null
            fi
            ssh -A -tt $PROXY_PREF$PROFILE$PROXY_SUF ssh -o StrictHostKeyChecking=no -o ConnectTimeout=2 baya@$ip
        else
            if [ $USEPROXY -eq 0 ]; then
                ssh -o StrictHostKeyChecking=no -o ConnectTimeout=2 baya@$ip -qo PasswordAuthentication=no 2>&1 $REMOTE_CMD
            else
                ssh -qA -tt $PROXY_PREF$PROFILE$PROXY_SUF ssh -o StrictHostKeyChecking=no -o ConnectTimeout=2 baya@$ip -qo PasswordAuthentication=no "'$REMOTE_CMD'"
            fi
        fi
        RES=$?
        if [ $RES -ne 255 ]; then break; fi # 255 is code of no ssh

        #verbose $1 "ERROR: $RES"
        if [ $USEPROXY -eq 0 ]; then
            verbose $1 "Using proxy ..."
            USEPROXY=1
            continue
        else
            USEPROXY=0
        fi
        if [ "x$otherip" != "x" ]; then
            ip=`echo "$otherip" | awk -F ',' '{print $1}'`
            otherip=`echo "$otherip" | sed -E 's/^[^,]*,*(.*)$/\1/'`
            verbose $1 "Using other ip $ip ..."
            continue
        fi

        if [ "x$YES" = "x1" ]; then
            break
        fi
        verbose "Continue? [y/N]"
        read y
        if [ "x$y" != "xy" ]; then
            verbose "ABORTED"
            exit 1
        fi
        break
        #if [ $? -ne 0 ]; then
        #    add_key
        #    ssh $ip $REMOTE_CMD
    done
}

on_preExit() {
    echo
    #echo 'Exiting...' # Runs just before actual exit,
                       # shell will execute EXIT(0) after finishing this function
                       # that we hook also in on_exit function
    exit 2
}

if [ ! -z "$DEBUG" ]; then
    LOGDIR="/tmp/$ME.logs"
    rm -rf "$LOGDIR"
    mkdir -p "$LOGDIR"
else
    LOGDIR=`mktemp -d /tmp/$ME.XXXXXXXX`
    trap on_preExit 1 2 3 6 14 15 30 # HUP INT QUIT TERM STOP PWR  # 1 2 3 15 30
    trap "rm -rf '$LOGDIR'; kill 0; echo" 0 # EXIT
fi

RUNINPAR=0 WAITFOR=
for h in $HOSTS; do
    HOSTSEQNUM=`echo "$HOSTSEQNUM + 1" | bc`
    ip=`echo $h | awk -F '##' '{print $3}'`
    LF="$LOGDIR/$ip"
    touch "$LF"

    if [ $RUN_IN_PARALLEL -ne 1 ]; then
        exec 4>&1
        status=`{ { process_host 2>&1; printf $? 1>&3; } | tee "$LF" 1>&4; } 3>&1`
        exec 4>&-
        if [ "x$status" != "x0" ]; then break; fi
        #process_host 2>&1 | tee -a "$LF"
        #if [ ${PIPESTATUS[0]} -ne 0 ]; then break; fi
        continue
    fi

    printf " $ip"
    process_host "$LF" 2>&1 >> "$LF" &
    WAITFOR="$WAITFOR $!"
    RUNINPAR=`echo "$RUNINPAR + 1" | bc`
    if [ $RUNINPAR -ge 120 ]; then
        echo
        verbose "Waiting ..."
        wait $WAITFOR
        RUNINPAR=0 WAITFOR=
    fi
done

if [ $RUN_IN_PARALLEL -eq 1 ]; then
    echo
    verbose "Waiting for ssh requests ..."
    wait
fi

SUMMARY=`cat $LOGDIR/* | grep -v "$VERBOSE_PREFIX" | sed 's///g' | sort | uniq -c | sort -n`

if [ $RUN_IN_PARALLEL -eq 1 ]; then
    old_IFS=$IFS      # save the field separator
    cd "$LOGDIR"
    list=`ls`
    files=`grep -l " windows)" *`
    for F in $files; do
        list=`echo "$list" | grep -v $F`
        cat "$F"
    done
    verbose "Summarising `echo "$SUMMARY" | wc -l` lines ..."
    IFS='
'
    printf '.'
    SHOWORDER= L=0
    for S in $SUMMARY; do
        L=`echo "$L + 1" | bc`
        S=`echo "$S" | sed -E 's/^ *[0-9]* *(.*)$/\1/'`
        files=`grep -l -- "$S" *`
        for F in $files; do
            echo "$list" | grep -q "$F"
            if [ $? -ne 0 ]; then continue ; fi

            list=`echo "$list" | grep -v $F`
            SHOWORDER="$F $SHOWORDER"
        done
        SHOWORDER="\n$SHOWORDER"
        if [ "x`echo "$L % 10" | bc`" = "x0" ]; then
            if [ "x`echo "$L % 100" | bc`" = "x0" ]; then
                printf $L
            else
                printf '.'
            fi
        fi
    done
    echo $L
    echo
    SHOWORDER=`echo "$SHOWORDER"`
    IFS=$old_IFS
    for S in $SHOWORDER; do
        cat $S
    done
    for F in $list; do
        cat "$F"
    done
fi

verbose "DONE"

if [ "x$SHOW_SUMMARY" = "x1" ]; then
    SUMMARY=`echo "$SUMMARY" | sort -rn`
    echo
    printf -- "------ SUMMARY of %3d hosts -------------\n" $HOSTTODOCOUNT
    echo "$SUMMARY"
    echo     "------ SUMMARY END ----------------------"
fi
